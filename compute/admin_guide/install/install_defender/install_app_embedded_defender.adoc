== App-Embedded Defender

App-Embedded Defenders monitor and protect your containers at runtime to ensure they execute as designed, protecting them from suspicious processes, outbound network connections, and file system activity.

To learn when to use App-Embedded Defenders, see xref:../../install/defender_types.adoc[Defender types].

To learn more about App-Embedded Defender's runtime protection capabilities, see xref:../../runtime_defense/runtime_defense_app_embedded.adoc[runntime defense for App-Embedded].

For front-end containers, deploy the xref:../../waas/waas.adoc[WAAS] application firewall for additional runtime protection.

NOTE: App-Embedded Defender is the only supported option for securing containers at runtime when you're using nested virtualization, also known as _Docker-in-Docker_.
Docker-in-Docker is a setup where you have a Docker container that itself has Docker installed, and from within the container you use Docker to pull images, build images, run containers, and so on.
To secure the containers inside a container, use App-Embedded Defender.


=== Securing containers

To secure a container, embed the App-Embedded Defender into it.
You can embed App-Embedded Defenders with the Console UI, twistcli, or Prisma Cloud API.
App-Embedded Defender has been tested on Azure Container Instances, Google Cloud Run, and Fargate on EKS.

The steps are:

. Define your policy in Prisma Cloud Console.
+
App-Embedded Defenders dynamically retrieve rules from Console as they are updated.
You can embed the App-Embedded Defender into a task with a simple initial policy, and then refine it later, as needed.

. Embed the App-Embedded Defender into the container.

. Start the service that runs your container.

The embed process takes a Dockerfile as input, and returns a ZIP file with an augmented Dockerfile and App-Embedded Defender binaries.
Rebuild your container image with the new Dockerfile to complete the embedding process.
The embed process modifies the container's entrypoint to run App-Embedded Defender.
The App-Embedded Defender, in turn, runs the original entrypoint program under its control.

When embedding App-Embedded Defender, specify a unique identifier for your container image.
This gives you a way to uniquely identify the App-Embedded Defender in the environment.

When securing your apps with runtime rules, target rules to apps using the App ID.
(Because the App-Embedded Defender runs inside the container, it can't reliably get information such as image and container names.)

image::install_app_embedded_defender_scope_app_id.png[width=500]


[.task]
=== Embed App-Embedded Defender

Embed App-Embedded Defender into a container image from Console's UI.

*Prerequisites:*

* At runtime, the container where you're embedding App-Embedded Defender can reach Console over the network.
For Enterprise Edition, Defender talks to Console on port 443.
For Compute Edition, Defender talks to Console on port 8084.
* You have the Dockerfile for your image.

[.procedure]
. Open Console, and go to *Manage > Defenders > Deploy > Defenders*.

. In *Deployment method*, select *Single Defender*.

. Select the DNS name or IP address that App-Embedded Defender uses to connect to Console.

. In *Choose the Defender type*, select *Container Defender - App-Embedded Defender*.

. In *Monitor file system events*, set the toggle to *On* if your runtime policy requires it.
+
If App-Embedded Defender is deployed with this setting turned on, the sensor will monitor file system events, regardless of how your runtime policy is configured, and could impact the underlying workload's performance.
+
If you later decide you want to disable the sensor completely, you must re-embed App-Embedded Defender with this setting turned off.
+
Conversely, if you deploy App-Embedded Defender with this setting disabled, and later decide you want file system protection, you'll need to re-embed App-Embedded with this setting enabled.
+
You can specify the xref:./config_app_embedded_fs_protection.adoc[default setting] for this toggle so it's set the same way for all App-Embedded Defender deployments.

. In *Deployment type*, select *Dockerfile*.

. In *App ID*, enter a unique identifier for the App-Embedded Defender.

. In *Dockerfile*, click *Choose File*, and upload the Dockerfile for your container image.

. Click *Create embedded ZIP*.
+
A file named _app_embedded_embed_help.zip_ is created and downloaded to your system.

. Unpack app_embedded_embed_help.zip.

  $ mkdir tmp
  $ unzip app_embedded_embed_help.zip -d tmp/

. Build the modified Docker image.

  $ cd tmp/
  $ docker build .

. Tag and push the updated image to your repository.


[.task]
=== Embed App-Embedded Defender manually

Embed App-Embedded Defender into a container image manually.
Modify your Dockerfile with the supplied information, download the App-Embedded Defender binaries into the image's build context, then rebuild the image.

*Prerequisites:*

* At runtime, the container where you're embedding App-Embedded Defender can reach Console over the network.
For Enterprise Edition, Defender talks to Console on port 443.
For Compute Edition, Defender talks to Console on port 8084.
* The host where you're rebuilding your container image with App-Embedded Defender can reach Console over the network on port 8083.
* You have the Dockerfile for your image.

[.procedure]
. Open Console, and go to *Manage > Defenders > Deploy > Defenders*.

. In *Deployment method*, select *Single Defender*.

. Select the DNS name or IP address that App-Embedded Defender uses to connect to Console.

. In *Choose the Defender type*, select *Container Defender - App-Embedded Defender*.

. In *Monitor file system events*, set the toggle to *On* if your runtime policy requires it.
+
If App-Embedded Defender is deployed with this setting turned on, the sensor will monitor file system events, regardless of how your runtime policy is configured, and could impact the underlying workload's performance.
+
If you later decide you want to disable the sensor completely, you must re-embed App-Embedded Defender with this setting turned off.
+
Conversely, if you deploy App-Embedded Defender with this setting disabled, and later decide you want file system protection, you'll need to re-embed App-Embedded with this setting enabled.
+
You can specify the xref:./config_app_embedded_fs_protection.adoc[default setting] for this toggle so it's set the same way for all App-Embedded Defender deployments.

. In *Deployment Type*, select *Manual*.
+
A set of instructions for embedding App-Embedded Defender into your images is provided.

.. Using the provided curl command, download the App-Embedded Defender binary into your image's build context directory.

.. Open your Dockerfile for editing.

.. Add the App-Embedded Defender to the image.

  ADD twistlock_defender_app_embedded.tar.gz /twistlock/

.. Add the specified environment variables.
+
Be sure to set a value for `DEFENDER_APP_ID`, which is a unique identifier for the App-Embedded Defender.

.. Modify the entrypoint so that your app starts under the control of App-Embedded Defender.
+
For example, to start the hello-world program under the control of App-Embedded Defender, specify the following entrypoint.

  ENTRYPOINT ["/twistlock/defender", "app-embedded", "hello-world"]

. Rebuild your image.

  $ docker build .

. Tag and push the updated image to your repository.


[.task]
=== Embed App-Embedded Defender with twistcli

Prisma Cloud supports automation for embedding App-Embedded Defender into container images with either twistcli or the API.
This section shows you how to use twistcli.
To learn how to use the API, see the API docs.

*Prerequisites:*

* The container where you're embedding App-Embedded Defender can reach Console's port 8084 over the network.
* You have the Dockerfile for your image.

[.procedure]
. Download twistcli.

.. Log into Console, and go to *Manage > System > Utilities*.

.. Download the twistcli binary for your platform.

. Generate the artifacts for an updated container with twistcli.
+
A file named _app_embedded_embed_<app_id>.zip_ is created.
+
  $ ./twistcli app-embedded embed \
    --user <USER>
    --address "https://<CONSOLE>:8083" \
    --console-host <CONSOLE> \
    --app-id "<DEFENDER-ID>"  \
    --data-folder "<DATA-FOLDER>"  \
    Dockerfile
+
* <USER> -- Name of a Prisma Cloud user with a minimum xref:../../authentication/user_roles.adoc[role] of Defender Manager.
* <CONSOLE> -- DNS name or IP address for Console.
* <APP-ID> -- Unique identifier for the App-Embedded Defender.
For example, _my-app_.
* <DATA-FOLDER> -- Readable and writable directory in the container's filesystem.
For example, _/tmp_.
* To enable file system protection, add the `--filesystem-monitoring` flag to the twistcli command.

. Unpack _app_embedded_embed_help.zip_.

  $ mkdir tmp
  $ unzip app_embedded_embed_help.zip -d tmp/

. Build the updated image.

  $ cd tmp/
  $ docker build .

. Tag and push the updated image to your repository.
