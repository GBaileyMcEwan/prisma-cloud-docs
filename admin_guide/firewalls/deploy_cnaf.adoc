== Deploying CNAF

CNAF can secure both containerized and non-containerized web apps. +
To deploy CNAF, create a new rule, and declare the entity to protect. 

Though deployment method varies slightly depending on the type of entity you're protecting, they all follow the following definition path:

. Define Rule Resource
. Define Application Scope
. Enable Relevant Protections


=== Understanding CNAF Rule Resources and Application Scope

CNAF rules are designed for applying best-suited protection for each part of your deployment. 
To achieve that, each rule has two types of scopes:

==== Rule Resources

This scope defines for each type of deployment a combination of one or more elements to which CNAF should attach itself in order to protect the web application:

* *_For Containerized Application_* - Containers, Images, Namespaces, Cloud Accounts IDs, Hosts. 
* *_For Non-Containerized Applications_* - Host on which the application is running
* *_For App Embedded_* - App ID
* *_For Serverless_* - Function Name 

==== Application List
The application list define the protected application's endpoints within the deployment as a combination of one or more of the following:

* *_Port (Required)_* - for containerized application the internal port on which the application's port is listening. For all other types, the externally facing port.
* *_HTTP hostname_*
* *_Base Path_* - allows for applying protection policy on certain paths of the application (e.g. "/admin/", "/product/*", etc.)
* *_TLS_* - TLS certificate to be used when expecting inbound encrypted traffic.

To better illustrate that, consider the following deployment scenario of a web application running on-top of a NGINX cluster:

image::./cnaf_deployment_example.png[width=650]

In this example, different policies apply for different parts of the application.

The steps for deploying a CNAF rule to protect the above described web application would be as follows:

. *Define Rule Resources* - The rule should apply on all NGINX images - regardless of the containers on which they run 
image:./cnaf_rule_scope.png[width=550]
. *Define protection policy for login, search and product endpoints* - setting OWASP Top-10 protection on “Prevent” and Geo-based access control on “Alert”
. *Define protection policy for the application’s API endpoints* - setting OWASP Top-10 and API protection on “Prevent” and HTTP header-based access control on “Alert”

Once defined, rule overview would reflect the following rule resource and application definitions:

image::./cnaf_rule_example.png[width=650]

* *_Rule Resources_* - Protection is applied to all NGINX images
* *_Application List_* - We deployed two policies each covering different endpoint in the application (defined by HTTP hostname, port and path combinations)

=== Deploying CNAF

[.task]
==== Deploying CNAF for containers

To deploy CNAF for containerized web applications, create a new rule, specify the image name, define application endpoints and select protections. CNAF only needs to be applied to images that transmit and receive HTTP/HTTPS traffic.

[.procedure]
. Open Console, and go to *Defend > Firewalls > Cloud Native App Firewall*.

. Select the *Container* tab +
image:./cnaf_deployment_types.png[width=400]

. Click *Add Rule*.

. Enter a *Rule Name* and *Notes* (Optional) for describing the rule.

. Define *Rule Resources* +
The rule resource section defines for each type of deployment a combination of image names and one or more elements to which CNAF should attach itself in order to protect the web application: +
image:./cnaf_container_rule_resources.png[width=550] +
*Note:* Applying a rule to all images using a wild card (`*`) is invalid and a waste of resources - instead, specify your web application related images.

. Click *Add New App*.

. Enter *App Definiton* Tab +
App Definition tab allows for a granular definition of the end points within your web application to be protected by current policy.
CNAF allows for defintion of multiple protected endpoint within each app definition. +
Protected endpoints can be defined in one of the following ways:
.. *Import definitions from a Swagger or OpenAPI file*
... Click on *Import* +
image:./cnaf_import_swagger.png[width=350]
... Select definition file to load 
.. *Manual definition of URLs as combination of HTTP Host, Port and Path*
... In the *General App Setup* tab, click on *Add Endpoint* +
image:./cnaf_add_endpoint.png[width=550]
... Specify endpoint details: +
image:./cnaf_endpoint_lineitem.png[width=550]
*** Enter *Port (required)* +
Specify TCP port, in the container, listening for inbound HTTP traffic
*** Enter *HTTP Hostname* (optional, wildcards supported) +
HTTP host names are specified in the form of [hostname]:[external port]. +
External port is defined as the TCP port on the host, listening for inbound HTTP traffic. If the the value of the external port is "80" it can be omitted. Examples: "*.example.com", "docs.example.com", "www.example.com:8080", etc. 
*** Enter *Path* (optional, wildcards supported): +
Base path for CNAF to match on when applying protections. +
Examples: "/admin/", "/" (root path only), "/*", /v2/api/", etc.
... If your app uses TLS, set *TLS* to *On*. CNAF must be able to decrypt and inspect HTTPS traffic to function properly. To facilitate that, upload your server's certificate and private key - concatenate public cert and private key (e.g. _cat server-cert.pem server-key > certs.pem_)
... If your app requires <<api_protection>>, select the "API Protection" tab and define for each path allowed methods, parameters, types, etc. See detailed definition instructions in the <<api_protection>> section below. 
... Click *Create Endpoint*

. Continue to *App Firewall* tab and select <<protections>> to enable.

. Continue to *Access Control* tab and select <<access_control>> to enable.

. Click *Save*.

. You should be redirected to the *Rule Overview* page. +
Select the created new rule to display *Rule Resources* and for each application a list of *protected endpoints* and *enabled protections*. +
image:./cnaf_rule_overview.png[width=650] +

. Test protected endpoint using the following *<<sanity_tests>>*

[.task]
==== Deploying CNAF for hosts

To deploy CNAF to protect a host running a non-containerized web app, create a new rule, specify the host(s) where it run, define application endpoints and select protections..

[.procedure]
. Open Console, and go to *Defend > Firewalls > Cloud Native App Firewall*.

. Select the *Host* tab +
image:./cnaf_deployment_types_host.png[width=400]

. Click *Add Rule*.

. Enter a *Rule Name* and *Notes* (Optional) for describing the rule.

. Define *Rule Resources* +
The rule resource section defines the hosts to which CNAF should attach itself in order to protect the web application: +
image:./cnaf_host_rule_resources.png[width=550] +
*Note:* Applying a rule to all hosts using a wild card (`*`) is invalid and a waste of resources.
CNAF only needs to be applied to hosts that run apps that transmit and receive HTTP/HTTPS traffic.

. Click *Add New App*.

. Enter *App Definiton* Tab +
App Definition tab allows for a granular definition of the end points within your web application to be protected by current policy.
CNAF allows for defintion of multiple protected endpoint within each app definition. +
Protected endpoints can be defined in one of the following ways:
.. *Import definitions from a Swagger or OpenAPI file*
... Click on *Import* +
image:./cnaf_import_swagger.png[width=350]
... Select definition file to load 
.. *Manual definition of URLs as combination of HTTP Host, Port and Path*
... In the *General App Setup* tab, click on *Add Endpoint* +
image:./cnaf_add_endpoint.png[width=550]
... Specify endpoint details: +
image:./cnaf_endpoint_lineitem.png[width=550]
*** Enter *Port (required)* +
Specify TCP port, in the container, listening for inbound HTTP traffic
*** Enter *HTTP Hostname* (optional, wildcards supported) +
HTTP host names are specified in the form of [hostname]:[external port]. +
External port is defined as the TCP port on the host, listening for inbound HTTP traffic. If the the value of the external port is "80" it can be omitted. Examples: "*.example.com", "docs.example.com", "www.example.com:8080", etc. 
*** Enter *Path* (optional, wildcards supported): +
Base path for CNAF to match on when applying protections. +
Examples: "/admin/", "/" (root path only), "/*", /v2/api/", etc.
... If your app uses TLS, set *TLS* to *On*. CNAF must be able to decrypt and inspect HTTPS traffic to function properly. To facilitate that, upload your server's certificate and private key - concatenate public cert and private key (e.g. _cat server-cert.pem server-key > certs.pem_)
... If your app requires <<api_protection>>, select the "API Protection" tab and define for each path allowed methods, parameters, types, etc. See detailed definition instructions in the <<api_protection>> section below. 
... Click *Create Endpoint*

. Continue to *App Firewall* tab and select <<protections>> to enable.

. Continue to *Access Control* tab and select <<access_control>> to enable.

. Click *Save*.

. You should be redirected to the *Rule Overview* page. +
Select the created new rule to display *Rule Resources* and for each application a list of *protected endpoints* and *enabled protections*. +
image:./cnaf_rule_overview.png[width=650] +

. Test protected endpoint using the following *<<sanity_tests>>*


[.task]
==== Deploying App Embedded CNAF Defender for containers

In some environments, Prisma Cloud Defender must be be embedded directly in the container it's protecting.
This type of Defender is known as App Embedded Defender.
App Embedded Defender can secure these types of containers with all of CNAF's protection capabilities.

The only difference is that App Embedded Defender runs as a reverse proxy to the container it's protecting.
As such, when you set up CNAF for App Embedded, you must specify the exposed external port where App Embedded Defender can listen, and the port (not exposed to the Internet) where your web application listens.
CNAF for App Embedded forwards the filtered traffic to your application's port - unless an attack is detected and you chose *Prevent* in your CNAF for Fargate rule.

When testing your Prisma Cloud-protected container, be sure you update the security group's inbound rules to permit TCP connections on the external port you entered in the CNAF rule.
This is the exposed port that allows you to access your web container.
To disable CNAF protection, disable the CNAF rule, and re-expose the application's real port by modifying the security group's inbound rule.

[.procedure]
. Embed App Embedded Defender into your container or Fargate task.

. Open Console, and go to *Defend > Firewalls > Cloud Native App Firewall*.

. Select the *Host* tab +
image:./cnaf_deployment_types_host.png[width=400]

. Click *Add Rule*.

. Enter a *Rule Name* and *Notes* (Optional) for describing the rule.

. Define *Rule Resources* +
The rule resource section defines the hosts to which CNAF should attach itself in order to protect the web application: +
image:./cnaf_host_rule_resources.png[width=550] +
*Note:* Applying a rule to all hosts using a wild card (`*`) is invalid and a waste of resources.
CNAF only needs to be applied to hosts that run apps that transmit and receive HTTP/HTTPS traffic.

. Click *Add New App*.

. Enter *App Definiton* Tab +
App Definition tab allows for a granular definition of the end points within your web application to be protected by current policy.
CNAF allows for defintion of multiple protected endpoint within each app definition. +
Protected endpoints can be defined in one of the following ways:
.. *Import definitions from a Swagger or OpenAPI file*
... Click on *Import* +
image:./cnaf_import_swagger.png[width=350]
... Select definition file to load 
.. *Manual definition of URLs as combination of HTTP Host, Port and Path*
... In the *General App Setup* tab, click on *Add Endpoint* +
image:./cnaf_add_endpoint.png[width=550]
... Specify endpoint details: +
image:./cnaf_endpoint_lineitem.png[width=550]
*** Enter *Port (required)* +
Specify TCP port, in the container, listening for inbound HTTP traffic
*** Enter *HTTP Hostname* (optional, wildcards supported) +
HTTP host names are specified in the form of [hostname]:[external port]. +
External port is defined as the TCP port on the host, listening for inbound HTTP traffic. If the the value of the external port is "80" it can be omitted. Examples: "*.example.com", "docs.example.com", "www.example.com:8080", etc. 
*** Enter *Path* (optional, wildcards supported): +
Base path for CNAF to match on when applying protections. +
Examples: "/admin/", "/" (root path only), "/*", /v2/api/", etc.
... If your app uses TLS, set *TLS* to *On*. CNAF must be able to decrypt and inspect HTTPS traffic to function properly. To facilitate that, upload your server's certificate and private key - concatenate public cert and private key (e.g. _cat server-cert.pem server-key > certs.pem_)
... If your app requires <<api_protection>>, select the "API Protection" tab and define for each path allowed methods, parameters, types, etc. See detailed definition instructions in the <<api_protection>> section below. 
... Click *Create Endpoint*

. Continue to *App Firewall* tab and select <<protections>> to enable.

. Continue to *Access Control* tab and select <<access_control>> to enable.

. Click *Save*.

. You should be redirected to the *Rule Overview* page. +
Select the created new rule to display *Rule Resources* and for each application a list of *protected endpoints* and *enabled protections*. +
image:./cnaf_rule_overview.png[width=650] +

. Test protected endpoint using the following *<<sanity_tests>>*

















. Go to *Defend > Firewalls > CNAF for App Embedded*.

. Click *Add rule*.

. Enter a rule name.

. Select *Alert* or *Prevent*.

. Enter a port number for *External Port*, and one for the web container's *Application Port*.
The external port is typically 80 for HTTP and 443 for HTTPS.
For this example, enter _443_ for the *External Port* and _8080_ for the *Application Port*.

. If your app uses TLS, set *TLS* to *True*, and upload your server's certificate and private key.
CNAF must be able to decrypt and inspect HTTPS traffic to function properly.

. Enter the Defender ID you specified when embedding App Embedded Defender.

. Click *Save*.
+
All traffic to your web container is now be examined and protected by the embedded App Embedded Defender.

. Test your CNAF-protected container, browse to its public IP address.
+
Specify the external port as defined in your CNAF rule.


[.task]
==== Deploying CNAF for serverless functions

When Serverless Defender is embedded in a function, it offers built-in web application firewall (WAF) capabilities, including protection against:

* SQL injection (SQLi) attacks
* Cross-site scripting (XSS) attacks
* Command injection (CMDi) attacks
* Local file system inclusion (LFI) attacks
* Code injection attacks

*Prerequisites:* You've already xref:../install/install_defender/install_serverless_defender.adoc[embedded Serverless Defender] into your function.

[.procedure]
. Open Console and go to *Defend > Firewalls > Cloud Native App Firewall > Serverless*.

. Click *Add rule*.

. Enter a rule name.

. Select *Alert* or *Prevent*.

. Select the protections to enable.

. Enter the functions to protect.
+
Use xref:../configure/rule_ordering_pattern_matching.adoc[pattern matching] to precisely target your rule.




[#protections]
=== CNAF Protections

[#api_protection]
==== API Protection





[#access_control]
=== CNAF Access Controls

==== CNAF Network Lists



[#sanity_tests]
=== CNAF Test Strings

[.task]
==== Test string matching against HTTP headers

CNAF lets you block web requests that contain specific strings in the header.
You can add any of the common headers used in web requests and specify the value to match on.
The value can be a full or partial string.
For partial strings, use xref:../configure/rule_ordering_pattern_matching.adoc#[pattern matching]

The following example uses the `User-Agent` header field and block access to all web requests whose user-agent field contains all extensions of string 'Moz'.

[.procedure]
. Open Console.

. Go to *Defend > Firewalls > CNAF*.

. Click on *Add rule*.

. In the *Create a New CNAF Rule* dialog:

.. In *Rule name*, enter a name for the rule.

. Click on the *Advanced* tab.
+
image::cnaf_793462.png[width=600]

. As seen in the figure, we set the action in Prisma Cloud to Deny HTTP headers with field value *User-Agent* and all matches of *Moz* value.

. Open a Firefox Mozilla web browser and try to navigate to Jenkins’ address. You will see the following response:
+
image::cnaf_793458.png[width=600]

. Go to *Monitor > Events* to see alerts logged by Prisma Cloud relating to this policy violation.
+
You will see an event of type header, with a message that looks like:
+
  Header 'User-Agent'='Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) Gecko/20100101 Firefox/54.0' is forbidden


[.task]
==== Test protection from SQLi

SQL Injection attack is an injection technique where the attacker injects malicious SQL statements against a database server in an attempt to bypass application’s authentication and authorization mechanisms.

The procedure below shows how Prisma Cloud can help protect your application against SQL injection attacks. Consider a wordpress application hosted in your environment.

[.procedure]
. Create a CNAF policy.

.. Enter a rule name, such as *wordpress*.

.. Set the *Action* to *Prevent*.

.. Check *Enable SQLi attack protection*.

.. In the *Images* filter, enter *wordp{asterisk}*

. Open the application in web browser and attempt an SQL injection attack.
+
image::cnaf_791468.png[width=800]
+
Response:
+
image::cnaf_793458.png[width=600]

. Go to *Monitor > Events* to see the alerts logged for this event.
+
You will see an event of type sqli, with a message that looks like:
+
  Detected SQLi using libinjection in html query. "1" and 1 union select.