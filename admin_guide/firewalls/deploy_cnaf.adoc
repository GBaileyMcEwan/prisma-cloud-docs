== Deploying CNAF

CNAF can secure both containerized and non-containerized web apps.
To deploy CNAF, create a new rule, and declare the entity to protect. 

Although the deployment method varies slightly depending on the type of entity you're protecting, the steps, in general, are:

. Define rule resource.
. Define application scope.
. Enable relevant protections.


=== Understanding CNAF rule resources and application scope

The CNAF rule engine is designed to let you tailor the best-suited protection for each part of your deployment. 
Each rule has two scopes:

* Rule resources.
* Application list.


==== Rule resources

This scope defines, for each type of deployment, a combination of one or more elements to which CNAF should attach itself in order to protect the web application:

* *_For containerized applications_* - Containers, images, namespaces, cloud cccounts IDs, hosts. 
* *_For non-containerized applications_* - Host on which the application is running.
* *_For containers protexted with App-Embedded Defender_* - App ID.
* *_For serverless functions_* - Function name.


==== Application list

This scope defines the protected application's endpoints within the deployment as a combination of one or more of the following:

* *_Port (Required)_* - For containerized applications, the internal port on which the application's port is listening.
For all other types, the externally facing port.
* *_HTTP hostname_*
* *_Base path_* - Lets you apply protection policy on certain paths of the application (e.g. "/admin/", "/product/*", etc.)
* *_TLS_* - TLS certificate to be used when expecting inbound encrypted traffic.

To better illustrate, consider the following deployment scenario for a web application running on-top of a NGINX cluster:

image::./cnaf_deployment_example.png[width=650]

In this example, different policies apply for different parts of the application.
The steps for deploying a CNAF rule to protect the above described web application would be as follows:

. *Define rule resources* - The rule should apply on all NGINX images, regardless of the containers on which they run 
+
image::./cnaf_rule_scope.png[width=550]

. *Define protection policy for login, search and product endpoints* - Set OWASP Top 10 protection to "Prevent" and geo-based access control to "Alert".

. *Define protection policy for the application’s API endpoints* - Set OWASP Top 10 and API protection to "Prevent" and HTTP header-based access control to "Alert".

Once the is defined, the rule overview shows the following rule resource and application definitions:

image::./cnaf_rule_example.png[width=650]

* *_Rule Resources_* - Protection is applied to all NGINX images
* *_Apps List_* - We deployed two policies each covering different endpoint in the application (defined by HTTP hostname, port and path combinations)

=== Deploying CNAF

[.task]
==== Deploying CNAF for containers

To deploy CNAF for containerized web applications, create a new rule, specify the image name, define application endpoints and select protections. CNAF only needs to be applied to images that transmit and receive HTTP/HTTPS traffic.

[.procedure]
. Open Console, and go to *Defend > Firewalls > Cloud Native App Firewall*.

. Select the *Container* tab.
+
image::./cnaf_deployment_types.png[width=400]

. Click *Add Rule*.

. Enter a *Rule Name* and *Notes* (Optional) for describing the rule.

. Define *Rule Resources*.
+
The rule resource section defines for each type of deployment a combination of image names and one or more elements to which CNAF should attach itself in order to protect the web application:
+
image::./cnaf_container_rule_resources.png[width=550]
+
NOTE: Applying a rule to all images using a wild card (`*`) is invalid and a waste of resources - instead, specify your web application related images.

. Click *Add New App*.

. In the *App Definition* tab, specify the endpoints in your web app that should be protected.
Each defined app can have multiple protected endpoints.
If you have a Swagger or OpenAPI file, click *Import*, and select the file to load.
Otherwise, skip to the next step to manually define your app's endpoints.
+
image::./cnaf_import_swagger.png[width=350]

. If you don't have a Swagger or OpenAPI file, manually define each endpoint by specfying the host, port, and path.

.. In the *General App Setup* tab, click *Add Endpoint*.
+
image::./cnaf_add_endpoint.png[width=550]

.. Specify endpoint details:
+
image::./cnaf_endpoint_lineitem.png[width=550]

.. Enter *Port (required)*
+
Specify the TCP port listening for inbound HTTP traffic.

.. Enter *HTTP Hostname* (optional, wildcards supported).
+
HTTP host names are specified in the form of [hostname]:[external port].
+
External port is defined as the TCP port on the host, listening for inbound HTTP traffic. If the the value of the external port is "80" non-TLS endpoints or "443" for TLS endpoints it can be omitted. Examples: "*.example.com", "docs.example.com", "www.example.com:8080", etc. 

.. Enter *Path* (optional, wildcards supported):
+
Base path for CNAF to match on when applying protections.
+
Examples: "/admin/", "/" (root path only), "/*", /v2/api/", etc.

.. If your app uses TLS, set *TLS* to *On*. CNAF must be able to decrypt and inspect HTTPS traffic to function properly. To facilitate that, upload your server's certificate and private key - concatenate public cert and private key (e.g. _cat server-cert.pem server-key > certs.pem_)

.. If your app requires <<api_protection>>, select the "API Protection" tab and define for each path allowed methods, parameters, types, etc. See detailed definition instructions in the <<api_protection>> section below. 

.. Click *Create Endpoint*

. Continue to *App Firewall* tab, select <<protections>> to enable and assign them with <<actions>>.

. Continue to *Access Control* tab and select <<access_control>> to enable.

. Click *Save*.

. You should be redirected to the *Rule Overview* page.
+
Select the created new rule to display *Rule Resources* and for each application a list of *protected endpoints* and *enabled protections*.
+
image::./cnaf_rule_overview.png[width=650]

. Test protected endpoint using the following *<<sanity_tests>>*


[.task]
==== Deploying CNAF for hosts

To deploy CNAF to protect a host running a non-containerized web app, create a new rule, specify the host(s) where it run, define application endpoints and select protections..

[.procedure]
. Open Console, and go to *Defend > Firewalls > Cloud Native App Firewall*.

. Select the *Host* tab
+
image::./cnaf_deployment_types_host.png[width=400]

. Click *Add Rule*.

. Enter a *Rule Name* and *Notes* (Optional) for describing the rule.

. Define *Rule Resources*.
+
The rule resource section defines the hosts to which CNAF should attach itself in order to protect the web application:
+
image::./cnaf_host_rule_resources.png[width=550]
+
NOTE: Applying a rule to all hosts using a wild card (`*`) is invalid and a waste of resources.
CNAF only needs to be applied to hosts that run apps that transmit and receive HTTP/HTTPS traffic.

. Click *Add New App*.

. In the App Definition tab, specify the endpoints in your web app that should be protected.
Each defined app can have multiple protected endpoints.
If you have a Swagger or OpenAPI file, click Import, and select the file to load.
Otherwise, skip to the next step to manually define your app’s endpoints.
+
image::./cnaf_import_swagger.png[width=350]

. If you don’t have a Swagger or OpenAPI file, manually define each endpoint by specfying the host, port, and path.

.. In the *General App Setup* tab, click on *Add Endpoint*
+
image::./cnaf_add_endpoint.png[width=550]

.. Specify endpoint details:
+
image::./cnaf_endpoint_lineitem.png[width=550]

.. Enter *Port (required)*.
+
Specify TCP port, in the container, listening for inbound HTTP traffic

.. Enter *HTTP Hostname* (optional, wildcards supported).
+
HTTP host names are specified in the form of [hostname]:[external port].
+
External port is defined as the TCP port on the host, listening for inbound HTTP traffic. If the the value of the external port is "80" non-TLS endpoints or "443" for TLS endpoints it can be omitted. Examples: "*.example.com", "docs.example.com", "www.example.com:8080", etc. 

.. Enter *Path* (optional, wildcards supported):
+
Base path for CNAF to match on when applying protections.
+
Examples: "/admin/", "/" (root path only), "/*", /v2/api/", etc.

.. If your app uses TLS, set *TLS* to *On*. CNAF must be able to decrypt and inspect HTTPS traffic to function properly. To facilitate that, upload your server's certificate and private key - concatenate public cert and private key (e.g. _cat server-cert.pem server-key > certs.pem_)

.. If your app requires <<api_protection>>, select the "API Protection" tab and define for each path allowed methods, parameters, types, etc. See detailed definition instructions in the <<api_protection>> section below. 

.. Click *Create Endpoint*

. Continue to *App Firewall* tab, select <<protections>> to enable and assign them with <<actions>>.

. Continue to *Access Control* tab and select <<access_control>> to enable.

. Click *Save*.

. You should be redirected to the *Rule Overview* page.
+
Select the created new rule to display *Rule Resources* and for each application a list of *protected endpoints* and *enabled protections*.
+
image::./cnaf_rule_overview.png[width=650]

. Test protected endpoint using the following *<<sanity_tests>>*


[.task]
==== Deploying CNAF for containers protected by App-Embedded Defender

In some environments, Prisma Cloud Defender must be be embedded directly in the container it's protecting.
This type of Defender is known as App Embedded Defender.
App Embedded Defender can secure these types of containers with all of CNAF's protection capabilities.

The only difference is that App Embedded Defender runs as a reverse proxy to the container it's protecting.
As such, when you set up CNAF for App Embedded, you must specify the exposed external port where App Embedded Defender can listen, and the port (not exposed to the Internet) where your web application listens.
CNAF for App Embedded forwards the filtered traffic to your application's port - unless an attack is detected and you chose *Prevent* in your CNAF for Fargate rule.

When testing your Prisma Cloud-protected container, be sure you update the security group's inbound rules to permit TCP connections on the external port you entered in the CNAF rule.
This is the exposed port that allows you to access your web container.
To disable CNAF protection, disable the CNAF rule, and re-expose the application's real port by modifying the security group's inbound rule.

To Embed App-Embedded CNAF into your container or Fargate task:

[.procedure]
. Open Console, and go to *Defend > Firewalls > Cloud Native App Firewall*.

. Select the *App Embedded* tab.
+
image::./cnaf_deployment_types_app_embedded.png[width=400]

. Click *Add Rule*.

. Enter a *Rule Name* and *Notes* (Optional) for describing the rule.

. Define *Rule Resources*.
+
The rule resource section defines the App IDs to which CNAF should attach itself in order to protect the web application:
+
image::./cnaf_host_rule_resources_app_embedded.png[width=550]

. Click *Add New App*.

. In the App Definition tab, specify the endpoints in your web app that should be protected.
Each defined app can have multiple protected endpoints.
If you have a Swagger or OpenAPI file, click Import, and select the file to load.
Otherwise, skip to the next step to manually define your app’s endpoints.
+
image::./cnaf_import_swagger.png[width=350]

. If you don’t have a Swagger or OpenAPI file, manually define each endpoint by specfying the host, port, and path.

.. In the *General App Setup* tab, click on *Add Endpoint*.
+
image::./cnaf_add_endpoint.png[width=550]

.. Specify endpoint details:
+
image::./cnaf_endpoint_lineitem_app_embbded.png[width=550]

.. Enter *Port (required)*
+
Specify TCP port, in the container, listening for inbound HTTP traffic

.. Enter *External Port (required)*.
+
External port is the TCP port for the App-Embedded Defender to listen on for inbound HTTP traffic.

.. Enter *HTTP Hostname* (optional, wildcards supported).
+
HTTP host names are specified in the form of [hostname]:[external port].
+
External port is defined as the TCP port on the host, listening for inbound HTTP traffic. If the the value of the external port is "80" non-TLS endpoints or "443" for TLS endpoints it can be omitted. Examples: "*.example.com", "docs.example.com", "www.example.com:8080", etc.  

.. Enter *Path* (optional, wildcards supported):
+
Base path for CNAF to match on when applying protections.
+
Examples: "/admin/", "/" (root path only), "/*", /v2/api/", etc.

.. If your app uses TLS, set *TLS* to *On*. CNAF must be able to decrypt and inspect HTTPS traffic to function properly. To facilitate that, upload your server's certificate and private key - concatenate public cert and private key (e.g. _cat server-cert.pem server-key > certs.pem_)

.. If your app requires <<api_protection>>, select the "API Protection" tab and define for each path allowed methods, parameters, types, etc. See detailed definition instructions in the <<api_protection>> section below. 

.. Click *Create Endpoint*

. Continue to *App Firewall* tab, select <<protections>> to enable and assign them with <<actions>>.

. Continue to *Access Control* tab and select <<access_control>> to enable.

. Click *Save*.

. You should be redirected to the *Rule Overview* page.
+
Select the created new rule to display *Rule Resources* and for each application a list of *protected endpoints* and *enabled protections*.
+
image::./cnaf_rule_overview.png[width=650]

. Test protected container using the following *<<sanity_tests>>*

[.task]
==== Deploying CNAF for serverless functions

When Serverless Defender is embedded in a function, it offers built-in web application firewall (WAF) capabilities, including protection against:

* SQL injection (SQLi) attacks
* Cross-site scripting (XSS) attacks
* Command injection (CMDi) attacks
* Local file system inclusion (LFI) attacks
* Code injection attacks

NOTE: Some <<protections>> are not available for CNAF firewall deployment.

*Prerequisites:* You've already xref:../install/install_defender/install_serverless_defender.adoc[embedded Serverless Defender] into your function.

[.procedure]
. Open Console and go to *Defend > Firewalls > Cloud Native App Firewall > Serverless*.

. Click *Add rule*.

. Enter a rule name.

. Select *Alert* or *Prevent*.

. Select the protections to enable.

. Enter the functions to protect.
+
Use xref:../configure/rule_ordering_pattern_matching.adoc[pattern matching] to precisely target your rule.


[#actions]
=== CNAF actions
Requests that trigger CNAF's protection are subject to one of the following actions:

* *Alert* - Request is passed to the protected application and an audit is generated for visibility.
* *Prevent* - Request is denied from reaching the protected application, an audit is generated and CNAF responds with an HTML banner indicating the request was blocked.
* *Ban* - All requests originating from the same IP to the protected application are denied for a time period of 5 minutes within the last detected attack (Penalty Box).

NOTE: CNAF implements state, which is required for banning user sessions by IP address.
Because Defenders do not share state, any app that is replicated across multiple nodes must enable IP stickiness on the load balancer.

[#protections]
=== CNAF protections

image::./cnaf_firewall_protections.png[width=750]

==== OWASP Top 10 protection

CNAF offers protection for the critical security risks described in the OWASP Top Ten list.

===== SQL injection

An SQL injection (SQLi) attack inserts an SQL query into the input fields of a web application.
A successful attack can read sensitive data from the database, modify data in the database, or run admin commands.

CNAF converts input streams (requests) into tokens, and then searches for matching fingerprints of known problematic patterns.


===== Cross site scripting

Cross-Site Scripting (XSS) are a type of injection attack, in which malicious scripts are injected into otherwise benign and trusted websites.
Attackers try to trick the browser into switching to a Javascript context, and execute arbitrary code.

CNAF converts input streams (requests) into tokens, and then searches for matching fingerprints of known problematic patterns.


===== Command and code injection

Command injection is a form attack in which attackers attempt to run arbitrary commands on the web application's host.
Code injection is a form of attack in which code is injected and interpreted by the application or other micro-services.
Command and code payloads are either injected as part of sent HTTP requests or included from locally present or remote files (also known as File Inclusion).   

CNAF inspects all HTTP requests sent to the application and protects against all types of injection attacks as well as local file inclusions.

NOTE: Prisma Cloud architecture facilitates defense at-depth via multiple protection layers. Enabling xref:../runtime_defense/runtime_defense.adoc[Runtime Protection] in addition to CNAF would allow profiling of the application and identifying any anomalies resulting from command or code injections (e.g. unexpected new processes or DNS calls etc.)  


===== Local file inclusion

Local File Inclusion is a form of attack in which attackers attempt at gaining unauthorized access to locally stored sensitive files on the web application host. Such access attempts are often made using directory traversal attacks or exploiting file inclusion vulnerabilities in the application.

CNAF inspects all HTTP requests sent to the application for local file inclusion attacks aiming at sensitive system files as well as other various traversal attempts.


===== Attack tool and vulnerability scanners

Vulnerability scanners are automated tools scanning web applications for know security vulnerabilities and misconfiguration.

Crawler are automated tools designed to systematically access and enumerate content of web applications. 
Crawling can lead to data breaches by exposing resources that should not be publicly available, or revealing opportunities for hacking by exposing software versions, environment data, and so on.

CNAF is continuously updated with signatures of widely used web attack arsenal, crawlers and penetration tools.


[#api_protection]
==== API protection
CNAF is able to enforce API traffic based on definitions/specs provided in the form of https://swagger.io/[Swagger] or https://www.openapis.org/[OpenAPI] files.
In addition, CNAF also allows for manual API definition of paths, allowed methods, parameter names, types ranges etc.

Once defined, users can choose actions to apply on requests that do not comply with the API expected behavior.

===== Importing API definition from Swagger or OpenAPI

. Enter *App Definiton* Tab.
. Click on *Import*.
+
image::./cnaf_import_swagger.png[width=350]
. Select definition file to load
. Select *API Protection* Tab.
. Review path and parameter definitions
. Enter *App Firewall* Tab
. Assign *API Protection* protection relvant <<actions,action>>
+
image::./cnaf_api_protection_action.png[width=650]

===== Manual API definition

. Enter *App Definiton* Tab.
. Click *Add Endpoint* and enter API http hostnames and base paths.
. Select *API Protection* Tab.
+
image::./cnaf_api_protection.png[width=350]
. Click *Add Path*
. Enter *Resource Path* (e.g. _/product_)
. Select allowed *HTTP Methods*.
+
image::./cnaf_api_allowed_methods.png[width=350]
. For each allowed HTTP method, define parameter by selecting the method from *Parameters for* dropdown list.
+
image::./cnaf_api_protection_select_method.png[width=350].

. For each method add allowed parameters:
.. Click *Add Parameter* 
.. Enter parameter http://spec.openapis.org/oas/v3.0.3#parameter-object[definition]
+
image::./cnaf_api_add_parameter.png[width=550]
. Enter *App Firewall* Tab
. Assign *API Protection* protection relvant <<actions,action>>
+
image::./cnaf_api_protection_action.png[width=650]

NOTE: To apply actions on requests that does not contain defined parameters make sure to set the *Required* toggle to *On* for all defined parameters.

==== Security misconfigurations

===== Shellshock

Shellshock is a privilege escalation vulnerability that permits remote code execution.
In unpatched versions of bash, the Shellshock vulnerability lets attackers create environment variables with specially-crafted values that contain code.
As soon as the shell is invoked, the attacker's code is executed.

CNAF drops requests that are crafted to exploit the Shellshock vulnerability.

For more information about Shellshock, see
https://en.wikipedia.org/wiki/Shellshock_(software_bug)#Initial_report_(CVE-2014-6271)[CVE-2014-6271].


===== Malformed request protection

CNAF validates the structure of a request, automatically dropping those that are malformed.

Examples of malformed requests include:

* GET requests with a body.
* POST requests without a `Content-Length` header.


===== Cross-site request forgery

Cross-site request forgery (CSRF) tricks the victim's browser into executing unwanted actions on a web app in which the victim is currently authenticated.
CNAF mitigates CSRF by intercepting responses and setting the 'SameSite' cookie attribute to 'strict'.
The SameSite attribute prevents the browser from sending the cookie along with cross-site requests.
It only permits the cookie to be sent along with same-site requests.

There are several techniques for mitigating CSRF, including synchronizer (anti-CSRF) tokens, which developers must implement as part of your web app.
The synchronizer token pattern generates random challenge tokens associated with a user's session.
These tokens are inserted into forms as a hidden field, to be submitted along with your forms.
If the server cannot validate the token, the server rejects the requested action.

The SameSite cookie attribute works as a complementary defense against CSRF, and help mitigate against things such as faulty implementation of the synchronizer token pattern.

- When the SameSite attribute is not set, the cookie is always sent.

- With SameSite attribute is set to strict, the cookie is never sent in cross-site requests.

- With SameSite attribute set to lax, the cookie is only sent on same-site requests or top-level navigation with a safe HTTP method, such as GET.
It is not sent with cross-domain POST requests or when loading the site in a cross-origin frame.
It is sent when you navigate to a site by clicking on a <a href=...> link that changes the URL in your browser's address bar.

Currently, the
https://caniuse.com/#feat=same-site-cookie-attribute[following browsers support the SameSite attribute]:

* Chrome 61 or later.
* Firefox 58 or later.

For more information about the SameSite attribute, see https://tools.ietf.org/html/draft-west-first-party-cookies-07


===== Clickjacking

Web apps that permit their content to be embedded in a frame are at risk of clickjacking attacks.
Attackers can exploit permissive settings to invisibly load the target website into their own site and trick users into clicking on links which they never intended to click.

CNAF modifies all response headers, setting `X-Frame-Options` to `SAMEORIGIN`.
The `SAMEORIGIN` directive only permits a page to be displayed in a frame on the same origin as the page itself.


==== Intelligence gathering

Error messages give attackers insight into the inner workings of your app, so it's important to prevent information leakage.
The following controls limit the exposure of sensitive information:


[.section]
===== Brute force protection

CNAF limits the number of POST requests per minute, per IP.
If a threshold of more than thirty POST requests is exceeded in a short interval, the source IP is blocked for 5 minutes.
The brute force protection threshold is fixed and cannot be changed by users.
This prevents attackers from using brute to guess passwords and flood your app with unnecessary traffic.

NOTE: CNAF implements state, which is required for banning user sessions by IP address.
Because Defenders do not share state, any app that is replicated across multiple nodes must enable IP stickiness on the load balancer.

NOTE: "Brute-Force Protection" and "Track Response Error Codes" Protection share the same count of 30 requests per minute, per IP, per policy.
+
For example, IP accessing endpoints protected under the same policy, would get banned for 5 minutes when sending 20 POST requests and receiving 10 error responses from the server, as it would effectively meet the block threshold (20 POST + 10 errors = 30).    

[.section]
===== Track response error codes

Many failures in rapid succession can indicate that an automated attack is underway.
CNAF applies rate-based rules to mitigate these types of attacks.
Any HTTP response with a status code equal or greater than 400 is considered as a failure and would be included in the error rate counting.
If a threshold of more than thirty errors per minute, per IP is exceeded, the source IP is blocked for 5 minutes.
The response error codes rate threshold is fixed and cannot be changed by users.
If an attacker tries access non-existing URLs that are known admin pages for various web app frameworks, the source IP is immediately blocked for 5 minutes.

NOTE: CNAF implements state, which is required for banning user sessions by IP address.
Because Defenders do not share state, any app that is replicated across multiple nodes must enable IP stickiness on the load balancer.

NOTE: "Brute-Force Protection" and "Track Response Error Codes" Protection share the same count of 30 requests per minute, per IP, per policy.
+
For example, IP accessing endpoints protected under the same policy, would get banned for 5 minutes when sending 20 POST requests and receiving 10 error responses from the server, as it would effectively meet the block threshold (20 POST + 10 errors = 30).  

[.section]
===== Remove server fingerprints

Web applications that reveal their choice of software also reveal their susceptibility to known security holes.
Eliminating unnecessary headers makes it more difficult for attackers to identify the frameworks that underpin your app.

Response headers that advertise your app's web server and other server details should be scrubbed.
CNAF automatically removes unnecessary headers, such as `X-Powered-By`, `Server`, `X-AspNet-Version`, and `X-AspNetMvc-Version`.

[.section]
===== Detect information leakage

CNAF detects when the contents of critical files, such as _/etc/shadow_, _/etc/passwd_, and private keys, are contained in responses.
It also detects when responses contain directory listings, output from php_info(), and other similar leakage cases of potentially risky information.


[#access_control]
=== CNAF access controls
CNAF allows for control over how applications and end-users communicate with the protected web application.


==== Network lists

*Network Lists* allow customers to create and maintain user-defined named IP lists e.g. "branches", "Tor and VPN exit nodes", "business affiliates", etc.
List entries are composed of IPv4 addresses or CIDR blocks.

To access *Network Lists*, open Console, go to *Defend > Firewalls > Cloud Native App Firewall* and select the *Network List* tab.

image::./cnaf_network_lists.png[width=750]

List can be updated manually or via batch importing of entries from a CSV file. 
Once defined, *Network Lists* can be referenced and used in <<ip_network_controls>>.

NOTE: IPv6 entries are currently not supported.

==== Network controls

image::./cnaf_network_access.png[width=750]

[#ip_network_controls]
===== IP-based access control
Network lists can be used in CNAF for one of the following:

* *_Denied inbound IP Sources_* - CNAF would apply action of choice (Alert or Prevent) for IPs in Network lists.
* *_IP Exception List_* - Traffic originating from IP addresses listed in this category would not be inspected by any of the protections defined in this policy.

NOTE: We strongly advise users to practice caution when adding Network Lists to the IP Exception List as protections would not apply for traffic originating from such IPs.


===== Country-based cccess control

Specify country codes in one of the following categories (mutually exclusive):

* *_Denied Inbound Source Countries_* - CNAF would apply action of choice (Alert or Prevent) for requests originating from the specified country code.
* *_Allowed Inbound Source Countries_* - Requests originating from specified countries would be forwarded to the application (pending inspection). CNAF would apply action of choice (Alert or Prevent) on all other requests not originating from specified countries.

NOTE: Requests country origin is determined by the IP address associated with the request.

==== HTTP header controls

image::./cnaf_http_headers.png[width=750]

CNAF lets you block or allow requests that contain specific strings in HTTP headers by specifying a header name and a value to match.
The value can be a full or partial string.
Standard xref:../configure/rule_ordering_pattern_matching.adoc#pattern-matching[pattern matching] is supported.

If the *Required* toggle is set to *On* CNAF would apply the defined action on HTTP requests in which the specified HTTP header is missing.
When the *Required* toggle is set to *Off* no action will be applied for HTTP requests missing the specified HTTP header.

HTTP Header fields consist of a name, followed by a colon, and then the field value.
When deciphering field values, CNAF treats all commas as delimiters.
For example, the `Accept-Encoding` request header advertises which compression algorithm the client supports.

  Accept-Encoding: gzip, deflate, br

CNAF rules don't support exact matching when the value in a multi-value string contains a comma because CNAF treats all commas as delimiters.
To match this type of value, use wildcards.
For example, consider the following header:

  User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.108 Safari/537.36

To match it, specify the following wildcard expression in your CNAF rule:

  Mozilla/5.0*


==== File upload controls

image::./cnaf_file_upload.png[width=750]

Attackers might try to upload malicious files (malware) to your systems.
CNAF protects you against malware dropping by restricting uploads to just the files that match any allowed content types.
All other files are dropped.

Files are validated by both their extensions and their
https://en.wikipedia.org/wiki/File_(command)[magic numbers].
Built-in support is provided for the following file types:

* Audio: aac, mp3, wav.
* Compressed archives: 7zip, gzip, rar, zip.
* Documents: odf, pdf, Microsoft Office (legacy, Ooxml).
* Images: bmp, gif, ico, jpeg, png.
* Video: avi, mp4.

CNAF rules let you explicitly allow additional file extensions.
These allow lists provide a mechanism to extend support to file types with no built-in support, and as a fallback in case Prisma Cloud's built-in inspectors fail to correctly identify a file of a given type.
Any file with an allowed extension is automatically permitted through the firewall, regardless of its magic number.


[#sanity_tests]
=== cURL test commands

Below are curl-based tests to verify endpoints have been properly defined.
Make sure all changes are saved prior to running these tests.
The method for verifying test results differs according to the selected action:

* *Alert* - Go to *Monitor > Events* to see alerts logged by Prisma Cloud relating to this policy violation.
* *Prevent* - Commands return output similar to the following: 
+
  HTTP/1.1 403 Forbidden
  Date: Wed, 15 Jul 2020 12:51:50 GMT
  Content-Type: text/html; charset=utf-8

In the following examples, replace `<http_hostname>` with your endpoint's hostname and `<external_port>` with the web facing port of your application.
For testing HTTP header access control, also replace `<http_header_name>` with the header name set in the rule and `<http_header_value>` with set values.

SQL injection:

----
curl -I http://<http_hostname>:<external_port>/\?id\=%27%20OR%20%271
----

Cross-site scripting:

----
curl -I http://<http_hostname>:<external_port>/\?id\=\<script\>alert\(\1\)\>/script\>
----

OS command injection:

----
curl -I http://<http_hostname>:<external_port>/\?id\=/bin/sh/
----

Code injection:

----
curl -I http://<http_hostname>:<external_port>/\?id\=phpinfo()
----

Local file inclusion:

----
curl -I http://<http_hostname>:<external_port>/\?id\=../etc/passwd
----

Attack tools and vulnerability scanners:

----
curl -I -H 'User-Agent: sqlmap' http://<http_hostname>:<external_port>/
----

Shellshock protection:

----
curl -I -H "User-Agent: () { :; }; /bin/eject" http://<http_hostname>:<external_port>/
----

Malformed HTTP request:

----
curl -s -i -X GET -o /dev/null -D - -d '{"test":"test"}' http://<http_hostname>:<external_port>/
----

HTTP header access controls:

----
curl -H '<header_Name>: <header_value>' http://<http_hostname>:<external_port>/
----
